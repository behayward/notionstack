---
import BaseLayout from '../../layouts/BaseLayout.astro';
import ProductCard from '../../components/ProductCard.astro';
import { readdir, readFile } from 'fs/promises';
import { join } from 'path';

// Get all templates
const productsDir = join(process.cwd(), 'content/products');
let allProducts = [];

try {
  const files = await readdir(productsDir);
  const jsonFiles = files.filter(file => file.endsWith('.json'));

  for (const file of jsonFiles) {
    const filePath = join(productsDir, file);
    const content = await readFile(filePath, 'utf-8');
    const product = JSON.parse(content);
    // Only show templates with enhanced content and active status
    if (product.category === 'template' && product.status !== 'inactive' && product.enhancedContent) {
      allProducts.push(product);
    }
  }
} catch (error) {
  allProducts = [];
}

// Sort by revenue potential (paid + affiliate first)
allProducts.sort((a, b) => {
  const scoreA =
    (a.hasAffiliate && a.price > 0 ? 200 : 0) + // Paid WITH affiliate = best
    (a.price > 0 ? 100 : 0) + // Paid products
    (a.hasAffiliate ? 50 : 0) + // Has affiliate program
    (a.salesCount ? a.salesCount * 0.5 : 0) +
    (a.rating && a.ratingCount >= 3 && a.rating >= 4.0 ? a.rating * 10 : 0);

  const scoreB =
    (b.hasAffiliate && b.price > 0 ? 200 : 0) +
    (b.price > 0 ? 100 : 0) +
    (b.hasAffiliate ? 50 : 0) +
    (b.salesCount ? b.salesCount * 0.5 : 0) +
    (b.rating && b.ratingCount >= 3 && b.rating >= 4.0 ? b.rating * 10 : 0);

  return scoreB - scoreA;
});

// Get unique subcategories for filter
const subcategories = [...new Set(allProducts.map(p => p.subcategory).filter(Boolean))].sort();
---

<BaseLayout
  title="Notion Templates"
  description={`Browse ${allProducts.length} Notion templates`}
>
  <div class="products-page">
    <div class="container">
      <header class="page-header">
        <h1 id="page-title">All Templates</h1>
        <p class="product-count"><span id="product-count">{allProducts.length}</span> {allProducts.length === 1 ? 'template' : 'templates'}</p>
      </header>

      <div class="search-sort-bar">
        <div class="search-box">
          <input
            type="search"
            id="search-input"
            placeholder="Search templates..."
            class="search-input"
          />
        </div>
        <div class="sort-controls">
          <label for="sort-select">Sort by:</label>
          <select id="sort-select" class="sort-select">
            <option value="revenue">Best Value</option>
            <option value="rating">Highest Rated</option>
            <option value="price-high">Price: High to Low</option>
            <option value="price-low">Price: Low to High</option>
            <option value="free">Free First</option>
          </select>
        </div>
      </div>

      <div class="filters">
        <button data-category="" class="filter-btn filter-active">All Templates</button>
        {subcategories.map(cat => (
          <button data-category={cat} class="filter-btn filter-link">
            {cat}
          </button>
        ))}
      </div>

      <div class="products-grid" id="products-grid">
        {allProducts.map(product => (
          <div
            class="product-item"
            data-subcategory={product.subcategory || ''}
            data-name={product.name.toLowerCase()}
            data-description={(product.description || '').toLowerCase()}
            data-price={product.price || 0}
            data-rating={product.rating || 0}
            data-has-affiliate={product.hasAffiliate ? 'true' : 'false'}
            data-creator={(product.creator?.name || '').toLowerCase()}
          >
            <ProductCard product={product} />
          </div>
        ))}
      </div>
    </div>
  </div>
</BaseLayout>

<script>
  // Elements
  const filterButtons = document.querySelectorAll('.filter-btn');
  const productItems = Array.from(document.querySelectorAll('.product-item'));
  const pageTitle = document.getElementById('page-title');
  const productCount = document.getElementById('product-count');
  const searchInput = document.getElementById('search-input');
  const sortSelect = document.getElementById('sort-select');
  const productsGrid = document.getElementById('products-grid');

  let currentCategory = '';
  let currentSearchTerm = '';

  // Filter and sort products
  function updateProducts() {
    let visibleItems = productItems.filter(item => {
      // Category filter
      const itemCategory = item.dataset.subcategory;
      const matchesCategory = currentCategory === '' || itemCategory === currentCategory;

      // Search filter
      const matchesSearch = currentSearchTerm === '' ||
        item.dataset.name.includes(currentSearchTerm) ||
        item.dataset.description.includes(currentSearchTerm) ||
        item.dataset.creator.includes(currentSearchTerm);

      return matchesCategory && matchesSearch;
    });

    // Sort
    const sortValue = sortSelect.value;
    if (sortValue === 'revenue') {
      // Paid + affiliate first, then paid, then affiliate, then free
      visibleItems.sort((a, b) => {
        const aPrice = parseFloat(a.dataset.price);
        const bPrice = parseFloat(b.dataset.price);
        const aAffiliate = a.dataset.hasAffiliate === 'true';
        const bAffiliate = b.dataset.hasAffiliate === 'true';

        const aScore = (aPrice > 0 && aAffiliate ? 200 : 0) + (aPrice > 0 ? 100 : 0) + (aAffiliate ? 50 : 0);
        const bScore = (bPrice > 0 && bAffiliate ? 200 : 0) + (bPrice > 0 ? 100 : 0) + (bAffiliate ? 50 : 0);

        return bScore - aScore;
      });
    } else if (sortValue === 'rating') {
      visibleItems.sort((a, b) => parseFloat(b.dataset.rating) - parseFloat(a.dataset.rating));
    } else if (sortValue === 'price-high') {
      visibleItems.sort((a, b) => parseFloat(b.dataset.price) - parseFloat(a.dataset.price));
    } else if (sortValue === 'price-low') {
      visibleItems.sort((a, b) => parseFloat(a.dataset.price) - parseFloat(b.dataset.price));
    } else if (sortValue === 'free') {
      visibleItems.sort((a, b) => parseFloat(a.dataset.price) - parseFloat(b.dataset.price));
    }

    // Hide all first
    productItems.forEach(item => item.style.display = 'none');

    // Show and reorder visible items
    visibleItems.forEach(item => {
      item.style.display = 'block';
      productsGrid.appendChild(item);
    });

    // Update count
    productCount.textContent = visibleItems.length;

    // Update title
    if (currentCategory) {
      pageTitle.textContent = `${currentCategory.charAt(0).toUpperCase() + currentCategory.slice(1)} Templates`;
    } else {
      pageTitle.textContent = 'All Templates';
    }
  }

  // Category filter
  filterButtons.forEach(button => {
    button.addEventListener('click', () => {
      currentCategory = button.dataset.category;

      // Update active state
      filterButtons.forEach(btn => {
        btn.classList.remove('filter-active');
        btn.classList.add('filter-link');
      });
      button.classList.add('filter-active');
      button.classList.remove('filter-link');

      updateProducts();

      // Update URL
      const url = new URL(window.location);
      if (currentCategory) {
        url.searchParams.set('category', currentCategory);
      } else {
        url.searchParams.delete('category');
      }
      window.history.pushState({}, '', url);
    });
  });

  // Search
  searchInput.addEventListener('input', (e) => {
    currentSearchTerm = e.target.value.toLowerCase();
    updateProducts();
  });

  // Sort
  sortSelect.addEventListener('change', updateProducts);

  // Load from URL on page load
  const urlParams = new URLSearchParams(window.location.search);
  const categoryParam = urlParams.get('category');
  if (categoryParam) {
    filterButtons.forEach(btn => {
      if (btn.dataset.category === categoryParam) {
        btn.click();
      }
    });
  }
</script>

<style>
  .products-page {
    padding: 3rem 0 4rem;
    min-height: calc(100vh - 400px);
  }

  .container {
    max-width: 1280px;
    margin: 0 auto;
    padding: 0 2rem;
  }

  .page-header {
    text-align: center;
    margin-bottom: 2rem;
  }

  .page-header h1 {
    font-size: 2rem;
    font-weight: 700;
    color: var(--color-primary);
    margin-bottom: 0.5rem;
    letter-spacing: -0.03em;
  }

  .product-count {
    color: var(--color-secondary);
    font-size: 0.9375rem;
  }

  .search-sort-bar {
    display: flex;
    gap: 1rem;
    margin-bottom: 1.5rem;
    align-items: center;
    justify-content: center;
  }

  .search-box {
    flex: 1;
    max-width: 400px;
  }

  .search-input {
    width: 100%;
    padding: 0.625rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    font-size: 0.9375rem;
    font-family: inherit;
    transition: border-color 0.15s ease;
  }

  .search-input:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .sort-controls {
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .sort-controls label {
    font-size: 0.875rem;
    color: var(--color-secondary);
    font-weight: 500;
  }

  .sort-select {
    padding: 0.625rem 1rem;
    border: 1px solid var(--color-border);
    border-radius: 0.5rem;
    font-size: 0.875rem;
    font-family: inherit;
    background: white;
    cursor: pointer;
    transition: border-color 0.15s ease;
  }

  .sort-select:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .filters {
    display: flex;
    justify-content: center;
    gap: 0.5rem;
    margin-bottom: 2.5rem;
    flex-wrap: wrap;
  }

  .filter-btn {
    padding: 0.5rem 1rem;
    border-radius: 0.5rem;
    border: none;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.875rem;
    transition: all 0.15s ease;
    letter-spacing: -0.01em;
    text-transform: capitalize;
    font-family: inherit;
  }

  .filter-link {
    background: white;
    color: var(--color-secondary);
    border: 1px solid var(--color-border);
  }

  .filter-link:hover {
    background: #f9fafb;
    color: var(--color-primary);
  }

  .filter-active {
    background: var(--color-primary);
    color: white;
    border: 1px solid var(--color-primary);
  }

  .products-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
    gap: 1.5rem;
  }

  .product-item {
    display: block;
  }

  @media (max-width: 768px) {
    .products-page {
      padding: 3rem 0 4rem;
    }

    .container {
      padding: 0 1rem;
    }

    .page-header h1 {
      font-size: 2rem;
    }

    .search-sort-bar {
      flex-direction: column;
      gap: 0.75rem;
    }

    .search-box {
      max-width: 100%;
    }

    .sort-controls {
      width: 100%;
      justify-content: space-between;
    }

    .sort-select {
      flex: 1;
    }

    .filters {
      gap: 0.5rem;
    }

    .products-grid {
      grid-template-columns: 1fr;
    }
  }
</style>
